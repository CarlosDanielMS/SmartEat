// Importa o Axios e os tipos auxiliares
import axios, { AxiosError, AxiosInstance } from "axios";

// Fun√ß√µes utilit√°rias para lidar com tokens no armazenamento (ex.: AsyncStorage)
import {
  getAccessToken,
  getRefreshToken,
  setTokens,
  clearTokens,
} from "../auth/tokens";

// üîπ Base URL da API
// - Emulador Android ‚Üí usa 192.168.0.138 para acessar localhost da m√°quina
// - iOS Simulator ‚Üí pode usar "localhost"
// - Aqui est√° fixo no IP local da rede
const BASE_URL = "http://192.168.0.213:4000";

// Cria inst√¢ncia do Axios com baseURL e timeout de 10s
export const API: AxiosInstance = axios.create({
  baseURL: BASE_URL,
  timeout: 10000,
});

// üîπ Inicializa header Authorization com token armazenado (se existir)
(async () => {
  const access = await getAccessToken();
  if (access) API.defaults.headers.common.Authorization = `Bearer ${access}`;
})();

// Controle de refresh em andamento
let refreshing = false;

// Fila de "esperando refresh" ‚Üí cada waiter √© uma Promise pendente
let waiters: { resolve: (t: string) => void; reject: (e: unknown) => void }[] =
  [];

// Adiciona requisi√ß√£o √† fila (quando refresh est√° em andamento)
function enqueueWaiter() {
  return new Promise<string>((resolve, reject) =>
    waiters.push({ resolve, reject })
  );
}

// Resolve todas as requisi√ß√µes pendentes com novo token
function resolveWaiters(token: string) {
  waiters.forEach((w) => w.resolve(token));
  waiters = [];
}

// Rejeita todas as requisi√ß√µes pendentes (falha no refresh)
function rejectWaiters(err: unknown) {
  waiters.forEach((w) => w.reject(err));
  waiters = [];
}

// üîπ Interceptor de resposta do Axios
API.interceptors.response.use(
  // Caso sucesso ‚Üí retorna normalmente
  (res) => res,

  // Caso erro ‚Üí intercepta
  async (error: AxiosError) => {
    const original: any = error.config || {};

    // Se resposta foi 401 (n√£o autorizado) e n√£o tentamos retry ainda
    if (error.response?.status === 401 && !original._retry) {
      original._retry = true; // evita loop infinito

      // Caso j√° esteja em refresh, aguarda na fila
      if (refreshing) {
        const token = await enqueueWaiter();
        // Reaplica novo token no header
        original.headers = {
          ...original.headers,
          Authorization: `Bearer ${token}`,
        };
        return API(original); // reexecuta a requisi√ß√£o original
      }

      try {
        refreshing = true; // marca que refresh est√° em andamento

        // Obt√©m refresh token armazenado
        const refreshToken = await getRefreshToken();
        if (!refreshToken) throw new Error("No refresh token");

        // Faz chamada √† API de refresh
        const { data } = await API.post("/auth/refresh", { refreshToken });
        const { accessToken, refreshToken: newRefresh } = data;

        // Atualiza tokens no armazenamento
        await setTokens(accessToken, newRefresh);

        // Atualiza header padr√£o com novo access token
        API.defaults.headers.common.Authorization = `Bearer ${accessToken}`;

        // Libera fila de requisi√ß√µes pendentes com novo token
        resolveWaiters(accessToken);

        // Reaplica token na requisi√ß√£o original
        original.headers = {
          ...original.headers,
          Authorization: `Bearer ${accessToken}`,
        };
        return API(original); // reexecuta a requisi√ß√£o original
      } catch (e) {
        // Falha ‚Üí rejeita todas as pend√™ncias
        rejectWaiters(e);

        // Limpa tokens salvos
        await clearTokens();

        // Aqui poderia redirecionar para tela de Login, ex. via evento global
        return Promise.reject(e);
      } finally {
        refreshing = false; // libera o "lock" de refresh
      }
    }

    // Se n√£o for erro 401 ‚Üí propaga erro normalmente
    return Promise.reject(error);
  }
);
