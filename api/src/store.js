// Biblioteca para criptografia de senhas
// bcrypt √© usado para armazenar senhas de forma segura, evitando texto puro.
// O hash √© irrevers√≠vel: mesmo que o banco seja comprometido, as senhas reais n√£o s√£o expostas.
import bcrypt from 'bcrypt';

// Estrutura de dados em mem√≥ria simulando um "banco de dados"
export const db = {
  // Armazena usu√°rios cadastrados
  // Chave = userId
  // Valor = objeto com dados do usu√°rio (id, email, hash da senha, roles/pap√©is)
  users: new Map(),

  // Armazena refresh tokens emitidos
  // Chave = jti (JWT ID do refresh token)
  // Valor = objeto com dados do token (quem √© o dono, expira√ß√£o e revoga√ß√£o)
  refreshTokens: new Map(),
};

// üîπ SEED (pr√©-popula√ß√£o do "banco" com usu√°rios de exemplo)
// √â executado imediatamente ao importar este arquivo.
(async () => {
  /**
   * Fun√ß√£o auxiliar para criar usu√°rio
   * - Recebe: id, email, senha em texto puro, lista de roles (padr√£o = ["user"])
   * - Gera um hash seguro da senha com bcrypt
   * - Salva no "db.users" com os dados necess√°rios
   */
  const mkUser = async (id, email, password, roles = ['user']) => {
    // Gera o hash da senha usando bcrypt
    // O "10" √© o n√∫mero de rounds de salt (quanto maior, mais seguro, mas mais lento)
    const passwordHash = await bcrypt.hash(password, 10);

    // Salva usu√°rio no Map (em mem√≥ria)
    db.users.set(id, { id, email, passwordHash, roles });
  };

  // Cria usu√°rio administrador com roles ['admin', 'user']
  await mkUser('u1', 'admin@example.com', 'admin123', ['admin', 'user']);

  // Cria usu√°rio comum apenas com role ['user']
  await mkUser('u2', 'user@example.com', 'user123', ['user']);
})();
