# React Native

## Criando um projeto com React Native no Expo

Para criar um projeto do zero em React Native com TypeScript usando Expo, o processo √© bastante simplificado, j√° que o Expo cuida de muita da configura√ß√£o automaticamente. Aqui est√° um passo a passo:

1. Instalar o Expo CLI
   O Expo CLI √© uma ferramenta de linha de comando que facilita a cria√ß√£o e execu√ß√£o de projetos React Native. Primeiro, voc√™ precisar√° instalar o expo-cli globalmente.

```bash
npm install -g expo-cli
```

2. Criar um Projeto com Expo e TypeScript
   Depois de instalar o Expo CLI, voc√™ pode criar um novo projeto. O Expo possui um template pronto para TypeScript.

```bash
expo init MeuProjeto
```

Ap√≥s rodar esse comando, o Expo perguntar√° qual template deseja usar. Selecione a op√ß√£o "blank (TypeScript)":

```bash
? Choose a template: (Use arrow keys)
  ----- Managed workflow -----
  blank
> blank (TypeScript)  <- Escolha esta op√ß√£o
  blank (JavaScript)
  tabs (TypeScript)
```

O Expo ir√° gerar o projeto com toda a configura√ß√£o necess√°ria para usar TypeScript.

3. Navegar para o Diret√≥rio do Projeto
   Assim que o projeto for criado, entre no diret√≥rio do projeto rec√©m-gerado:

```bash
cd MeuProjeto
```

4. Rodar o Projeto
   Agora, voc√™ pode iniciar o servidor de desenvolvimento Expo, que permitir√° testar o app em um dispositivo f√≠sico, emulador ou no navegador.

```bash
expo start ou npx expo start
```

Este comando abrir√° o Expo Developer Tools no seu navegador. A partir da√≠, voc√™ pode:

Usar o Expo Go App no seu dispositivo m√≥vel (iOS/Android) para visualizar o projeto escaneando o QR Code.
Rodar em um emulador Android ou iOS, se estiver com o ambiente configurado.

Caso necess√°rio, pode rodar **npm uninstall -g expo-cli**

---

## Autentica√ß√£o e Autoriza√ß√£o em React Native

Autentica√ß√£o e autoriza√ß√£o em **React Native** s√£o dois pilares essenciais para qualquer aplica√ß√£o que lida com dados de usu√°rios, integra√ß√µes externas ou funcionalidades restritas. Vamos separar os conceitos e contextualizar no ambiente de desenvolvimento mobile.

---

### üîë Autentica√ß√£o

A autentica√ß√£o √© o processo de **verificar a identidade do usu√°rio**.  
Em outras palavras, √© quando o app precisa garantir que o usu√°rio √© quem ele diz ser.

No contexto de React Native, isso pode envolver diferentes estrat√©gias:

- **Login com credenciais (usu√°rio/senha):** m√©todo mais comum, geralmente apoiado por APIs REST ou GraphQL.
- **Tokens de autentica√ß√£o (JWT, OAuth2):** ap√≥s validar as credenciais, o servidor emite um token, que ser√° usado nas requisi√ß√µes subsequentes.
- **Integra√ß√µes sociais:** login via Google, Facebook, Apple ou outros provedores, usando protocolos como OAuth.
- **Biometria e m√©todos locais:** FaceID, TouchID ou PIN, muitas vezes combinados com autentica√ß√£o remota.

O objetivo aqui √© garantir que apenas usu√°rios v√°lidos consigam acessar o app ou iniciar uma sess√£o segura.

---

### üõ°Ô∏è Autoriza√ß√£o

A autoriza√ß√£o √© o processo de **definir o que o usu√°rio autenticado pode ou n√£o fazer** dentro da aplica√ß√£o.  
Ou seja, depois que o sistema sabe quem √© o usu√°rio, precisa verificar quais permiss√µes ele tem:

- **Baseada em pap√©is (RBAC ‚Äì Role-Based Access Control):** usu√°rios pertencem a pap√©is (admin, editor, leitor) que definem acessos.
- **Baseada em atributos (ABAC ‚Äì Attribute-Based Access Control):** permiss√µes derivam de condi√ß√µes mais detalhadas, como departamento, localiza√ß√£o, status da conta etc.
- **Baseada em escopos (OAuth2):** comum em APIs, define granularmente os recursos que um token pode acessar.

O foco √© garantir que mesmo usu√°rios autenticados n√£o ultrapassem os limites de acesso definidos.

---

### üîí Boas pr√°ticas em React Native

- **Armazenamento seguro de tokens:** usar solu√ß√µes como SecureStore, Keychain (iOS) e Keystore (Android), evitando AsyncStorage para dados sens√≠veis.
- **Fluxo de renova√ß√£o de tokens:** refresh tokens ajudam a manter sess√µes ativas sem exigir login constante.
- **Prote√ß√£o de rotas:** implementar l√≥gica de navega√ß√£o que s√≥ permite acessar determinadas telas se o usu√°rio estiver autenticado e autorizado.
- **Integra√ß√£o com backend:** a verifica√ß√£o final de permiss√µes deve ser feita no servidor, o app atua como camada de controle inicial.

---

**Resumindo:**

- **Autentica√ß√£o** garante _quem √© o usu√°rio_.
- **Autoriza√ß√£o** garante _o que ele pode fazer_.

No React Native, ambos devem ser planejados em conjunto com a API/backend, respeitando pr√°ticas de seguran√ßa e uma boa experi√™ncia de uso.

## üîÅ Conceitos de Refresh Token

### O que √©

- **Access token:** credencial de curta dura√ß√£o (ex.: 5‚Äì15 min) usada para autorizar chamadas √† API.
- **Refresh token:** credencial de longa dura√ß√£o (ex.: dias/semanas) usada apenas para obter um novo par `{access, refresh}` quando o access expira ‚Äî n√£o deve autorizar recursos de neg√≥cio.

### Por que existe

- Minimiza a janela de ataque: mesmo se um access token vazar, ele expira r√°pido.
- Evita logins frequentes: mant√©m a sess√£o do usu√°rio por mais tempo, de forma segura.

### Como funciona (ciclo padr√£o)

1. Usu√°rio faz login ‚Üí servidor emite `{accessToken curto, refreshToken longo}`.
2. Cliente usa apenas o access token nas requisi√ß√µes.
3. Ao expirar (ou pouco antes), o cliente chama `/auth/refresh` com o refresh token.
4. Servidor valida o refresh token e emite novo par `{novoAccess, novoRefresh}`.
5. **Rota√ß√£o:** o refresh token antigo √© revogado (one-time use). Se algu√©m tentar reutiliz√°-lo, detecta-se **replay**.

### Boas pr√°ticas essenciais

- **Rota√ß√£o de refresh token (one-time use):** toda renova√ß√£o deve:
  - invalidar o refresh anterior,
  - registrar o novo (com jti, expira√ß√£o, device) e
  - retornar o novo par ao cliente.
- **Lista de revoga√ß√£o/estado no servidor:** guardar o jti (ID do refresh) com status (v√°lido, revogado, expirado) para:
  - logout, troca de senha, mudan√ßa de pap√©is,
  - detectar reuso (se o token antigo reaparecer, sinal de comprometimento ‚Üí derrubar a sess√£o/dispositivo).
- **Vidas diferentes:**
  - access: curto (minutos).
  - refresh: mais longo (dias/semanas) com limites (ex.: 30 dias desde o primeiro uso).
- **Escopo m√≠nimo:** refresh n√£o deve acessar dados do usu√°rio; apenas renovar credenciais.
- **Binding ao dispositivo (opcional, recomendado):** guardar deviceId, IP, user-agent ou fingerprint do app. Em caso de varia√ß√£o suspeita, exigir reautentica√ß√£o/MFA.
- **PKCE/OIDC (quando SSO):** preferir o padr√£o de mercado para reduzir riscos em fluxos m√≥veis.
- **Armazenamento seguro:** no mobile, Keychain/Keystore para refresh; evite AsyncStorage em produ√ß√£o para segredos.
- **TLS obrigat√≥rio + CORS restrito + rate limiting** em `/auth/refresh`.
- **Grace period (opcional):** janela curta para aceitar o refresh antigo e o novo, mitigando condi√ß√µes de corrida entre m√∫ltiplas abas/dispositivos.

### Padr√µes de sess√£o

- **Sliding session:** cada refresh ‚Äúestende‚Äù a validade, at√© um m√°ximo (ex.: 30 dias desde o login).
- **Idle timeout:** expirar refresh se ficar sem uso por X dias (inatividade).
- **Absolute timeout:** expirar refresh ap√≥s Y dias, independentemente de uso.

### Erros e respostas esperadas

- Refresh inv√°lido/expirado/revogado ‚Üí `401 Unauthorized` e o cliente deve destruir a sess√£o local e enviar o usu√°rio ao login.
- Reuso detectado (token antigo ap√≥s rota√ß√£o) ‚Üí `401` + sinaliza√ß√£o interna de poss√≠vel compromisso (opcionalmente invalidar toda a fam√≠lia de tokens daquele device/usu√°rio).

---

## üß≠ Rotas e Fluxo do Backend

### A API de exemplo exposta

**P√∫blicas**

- `GET /public/ping` ‚Äî teste simples (sem auth).

**Autentica√ß√£o**

- `POST /auth/register` ‚Äî (demo) cria usu√°rio.
- `POST /auth/login` ‚Äî valida credenciais e emite par `{access, refresh}`.
- `POST /auth/refresh` ‚Äî rotaciona o refresh token e retorna novo par.
- `POST /auth/logout` ‚Äî revoga o refresh atual.

**Protegidas**

- `GET /private/me` ‚Äî requer access token v√°lido.
- `GET /private/admin/metrics` ‚Äî requer access token v√°lido com papel admin.

### Middlewares centrais

- **requireAuth:**

  - L√™ `Authorization: Bearer <access>`.
  - Verifica assinatura e expira√ß√£o do access token.
  - Popula `req.user` com claims (ex.: sub, email, roles).
  - Caso falhe ‚Üí `401 Unauthorized`.

- **requireRole('admin'):**
  - L√™ `req.user.roles`.
  - Se n√£o incluir `admin` ‚Üí `403 Forbidden`.

### Emiss√£o e verifica√ß√£o de tokens

- **Access token (JWT assinado):**

  - Payload: `sub`, `email`, `roles`.
  - Expira em `JWT_ACCESS_EXPIRES` (ex.: 15m).
  - Usado exclusivamente para acessar rotas de neg√≥cio.

- **Refresh token (JWT assinado):**
  - Payload: `sub`, `jti` (ID √∫nico).
  - Expira em `JWT_REFRESH_EXPIRES` (ex.: 7d).
  - Persistido no servidor por `jti` para permitir revoga√ß√£o/rota√ß√£o.

### Fluxos detalhados

1. **Login**

- **Entrada:** `{ email, password }`
- **Processo:**
  - Localiza usu√°rio e compara senha (hash bcrypt).
  - Gera `jti` (UUID), emite:
    - `accessToken` (curto),
    - `refreshToken` (longo, contendo jti).
  - Salva registro do refresh (`jti, userId, expiresAt, revokedAt=null`).
  - Responde com `{ user, accessToken, refreshToken }`.
- **Erros:** credenciais inv√°lidas ‚Üí `401`.

2. **Acesso √† rota privada** (`/private/me`)

- **Entrada:** `Authorization: Bearer <access>`
- **Processo:**
  - `requireAuth` valida assinatura/exp.
  - Se ok, busca dados do usu√°rio e retorna perfil b√°sico.
- **Erros:** token ausente/ inv√°lido/ expirado ‚Üí `401`.

3. **Acesso com papel** (`/private/admin/metrics`)

- **Entrada:** `Authorization: Bearer <access>`
- **Processo:**
  - `requireAuth` valida o access.
  - `requireRole('admin')` checa roles.
  - Retorna m√©tricas.
- **Erros:** sem auth ‚Üí `401`; sem papel ‚Üí `403`.

4. **Refresh** (`/auth/refresh`)

- **Entrada:** `{ refreshToken }`
- **Processo:**
  - Verifica assinatura/exp do refresh com a chave de refresh.
  - Extrai `jti` e verifica na store se:
    - existe,
    - n√£o est√° revogado,
    - n√£o est√° expirado (pelo `exp`).
  - **Rota√ß√£o:**
    - marca o `jti` anterior como revogado,
    - emite novo par `{access, refresh}` com novo jti,
    - persiste o novo jti.
  - Responde `{ user, accessToken, refreshToken }`.
- **Erros:**
  - Refresh inv√°lido/expirado/revogado ‚Üí `401`.
  - (Opcional) detectar reuso: se um `jti` j√° revogado reaparecer, sinalizar comprometimento e derrubar sess√µes do usu√°rio/dispositivo.

5. **Logout** (`/auth/logout`)

- **Entrada:** `{ refreshToken }`
- **Processo:**
  - Extrai `jti` do refresh (sem precisar validar exp).
  - Marca esse `jti` como revogado.
  - Responde `{ ok: true }`.
- **Observa√ß√£o:** logout n√£o invalida o access token que ainda pode estar vivo por alguns minutos; por isso, o cliente deve apagar o access localmente e, idealmente, o backend deve aceitar somente chamadas com access v√°lido e n√£o permitir novos refreshs com o `jti` revogado.

### Sequ√™ncias (ASCII)

**A) Login inicial**

```
[App] --(email/senha)--> [/auth/login]
[API] --valida credenciais--> ok
[API] --emite--> access(15m), refresh(7d c/ jti)
[App] <-- tokens + perfil
```

**B) Chamada a rota privada**

```
[App] -- Authorization: Bearer access --> [/private/me]
[API] -- verifica access --> ok
[API] <-- dados do usu√°rio
```

**C) Renova√ß√£o com rota√ß√£o**

```
[App] -- {refresh} --> [/auth/refresh]
[API] -- verifica refresh + jti --> ok
[API] -- revoga jti antigo; emite novo par --> {access2, refresh2(jti2)}
[App] <-- tokens novos
```

**D) Logout**

```
[App] -- {refresh atual} --> [/auth/logout]
[API] -- revoga jti
[App] -- apaga tokens locais
```

### Estados e falhas para prever no cliente

- `401` na rota privada:
  - Tentar refresh uma √∫nica vez (single-flight: evitar m√∫ltiplos refresh paralelos).
  - Se refresh falhar ‚Üí limpar sess√£o e redirecionar para login.
- **Rede inst√°vel:**
  - Retry/backoff; se o access expirar no meio da fila, fazer refresh e replay da requisi√ß√£o.
- **Troca de senha/banimento:**
  - Revogar refresh tokens do usu√°rio; a pr√≥xima tentativa de refresh cai em `401` ‚Üí for√ßar reautentica√ß√£o.

### Notas de produ√ß√£o (al√©m do demo)

- Persistir refresh tokens em banco/Redis (n√£o em mem√≥ria).
- Assinatura assim√©trica (RS256) em vez de HS256 quando m√∫ltiplos servi√ßos validam tokens.
- TLS pinning no mobile (alto risco).
- MFA e pol√≠ticas adaptativas (geo/IP, hor√°rio, device).
- Auditoria: logar login/refresh/logout, erros 401/403, reusos detectados.
- Limitar escopo e payload do JWT (evitar PII no token).

---

# üì¶ AsyncStorage no React Native

## O que √©

**AsyncStorage** √© uma API de armazenamento persistente e ass√≠ncrona dispon√≠vel no React Native.  
Ela permite salvar **pares de chave-valor** no dispositivo do usu√°rio, funcionando de forma semelhante a um ‚ÄúlocalStorage‚Äù do navegador, mas com suporte a opera√ß√µes ass√≠ncronas.

√â bastante usada para guardar pequenas informa√ß√µes que precisam ser mantidas entre sess√µes, como prefer√™ncias, estado de login ou cache simples.

---

## Principais caracter√≠sticas

- **Ass√≠ncrono:** todas as opera√ß√µes retornam _Promises_, evitando travar a UI.
- **Persistente:** os dados ficam dispon√≠veis mesmo ap√≥s o usu√°rio fechar o app.
- **Baseado em chave-valor:** funciona como um dicion√°rio simples (`{ chave: valor }`).
- **Cross-platform:** compat√≠vel tanto com iOS quanto com Android.
- **Armazenamento simples:** voltado para pequenas quantidades de dados (n√£o substitui bancos locais como SQLite ou Realm).

---

## Como funciona

1. **Salvar dados:**  
   Voc√™ fornece uma chave (`string`) e um valor (`string`). O valor precisa ser serializado (ex.: JSON) se n√£o for texto simples.

   ```ts
   await AsyncStorage.setItem("user", JSON.stringify({ id: 1, name: "Alice" }));
   ```

2. **Ler dados:**  
   Recupera o valor associado √† chave. Se n√£o existir, retorna `null`.

   ```ts
   const user = await AsyncStorage.getItem("user");
   if (user) console.log(JSON.parse(user));
   ```

3. **Remover dados:**  
   Apaga a entrada associada √† chave.

   ```ts
   await AsyncStorage.removeItem("user");
   ```

4. **Opera√ß√µes m√∫ltiplas:**  
   Permite manipular v√°rias chaves de uma vez (`multiGet`, `multiSet`, `multiRemove`).

---

## Limita√ß√µes

- **Seguran√ßa:** os dados n√£o s√£o criptografados por padr√£o. N√£o √© adequado para informa√ß√µes sens√≠veis como senhas ou refresh tokens em produ√ß√£o (use **Keychain** no iOS e **Keystore** no Android).
- **Tamanho:** indicado para pequenos volumes de dados, n√£o para grandes cole√ß√µes ou dados bin√°rios.
- **Performance:** leituras e escritas muito grandes podem impactar a performance.

---

## Casos de uso comuns

- Guardar **token de sess√£o** (apenas para demonstra√ß√£o ou ambientes de baixo risco).
- Salvar **prefer√™ncias do usu√°rio** (tema, idioma, etc.).
- **Flags de onboarding** (ex.: ‚Äúj√° viu a introdu√ß√£o?‚Äù).
- Cache leve de informa√ß√µes que podem ser revalidadas com o backend.

---

## Alternativas para cen√°rios mais complexos

- **SecureStore (Expo), react-native-keychain ou EncryptedStorage:** quando for necess√°rio armazenamento seguro de credenciais.
- **SQLite / Realm / WatermelonDB:** quando o app precisa de persist√™ncia estruturada, consultas complexas ou grandes quantidades de dados.
- **MMKV (Meta):** alternativa mais r√°pida e eficiente para chave-valor.

---

Em resumo, o **AsyncStorage** √© ideal para **dados simples e n√£o sens√≠veis** que precisam persistir entre sess√µes. Para seguran√ßa ou escalabilidade, considere alternativas mais robustas.

---

# React Native Auth Demo (Expo + TS + Stack Navigation)

App Expo alinhado ao backend Express (JWT, refresh com rota√ß√£o e RBAC). Inclui:

- Login/Logout
- Armazenamento de tokens com AsyncStorage (did√°tico)
- Axios com interceptor de **refresh autom√°tico** e fila (single‚Äëflight)
- **Stack Navigation** com **rotas p√∫blicas**, **privadas** e **guard por papel (admin)**

> ‚ö†Ô∏è Produ√ß√£o: prefira Keychain/Keystore para guardar refresh token.

---

## üß∞ Criar o projeto do zero

```bash
# 1) Criar app Expo com TypeScript
npx create-expo-app rn-auth-demo -t expo-template-blank-typescript
cd rn-auth-demo

# 2) Instalar navega√ß√£o + deps nativas
npm i @react-navigation/native @react-navigation/native-stack
expo install react-native-screens react-native-safe-area-context

# 3) AsyncStorage e Axios
expo install @react-native-async-storage/async-storage
npm i axios

# (Opcional) Tipos
npm i -D @types/react @types/react-native

# 4) Rodar
npm run start
# Emulador Android: "a" | iOS: "i"
```

---

## üìÅ Estrutura sugerida

```
.
‚îú‚îÄ‚îÄ App.tsx
‚îú‚îÄ‚îÄ babel.config.js
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ api/
    ‚îÇ   ‚îî‚îÄ‚îÄ client.ts
    ‚îú‚îÄ‚îÄ auth/
    ‚îÇ   ‚îî‚îÄ‚îÄ tokens.ts
    ‚îú‚îÄ‚îÄ context/
    ‚îÇ   ‚îî‚îÄ‚îÄ AuthContext.tsx
    ‚îú‚îÄ‚îÄ navigation/
    ‚îÇ   ‚îî‚îÄ‚îÄ AppNavigator.tsx
    ‚îú‚îÄ‚îÄ components/
    ‚îÇ   ‚îî‚îÄ‚îÄ AdminOnly.tsx
    ‚îî‚îÄ‚îÄ screens/
        ‚îú‚îÄ‚îÄ SplashScreen.tsx
        ‚îú‚îÄ‚îÄ LoginScreen.tsx
        ‚îú‚îÄ‚îÄ HomeScreen.tsx
        ‚îî‚îÄ‚îÄ AdminScreen.tsx
```

---

## `babel.config.js`

```js
module.exports = function (api) {
  api.cache(true);
  return { presets: ["babel-preset-expo"] };
};
```

## `tsconfig.json`

```json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "moduleResolution": "node",
    "target": "esnext",
    "module": "esnext",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "types": ["react", "react-native"]
  }
}
```

---

## `src/auth/tokens.ts` (AsyncStorage + helpers)

```ts
import AsyncStorage from "@react-native-async-storage/async-storage";

const ACCESS_KEY = "accessToken";
const REFRESH_KEY = "refreshToken";

export async function setTokens(accessToken: string, refreshToken: string) {
  await AsyncStorage.multiSet([
    [ACCESS_KEY, accessToken],
    [REFRESH_KEY, refreshToken],
  ]);
}

export async function getAccessToken() {
  const v = await AsyncStorage.getItem(ACCESS_KEY);
  return v || "";
}

export async function getRefreshToken() {
  const v = await AsyncStorage.getItem(REFRESH_KEY);
  return v || "";
}

export async function clearTokens() {
  await AsyncStorage.multiRemove([ACCESS_KEY, REFRESH_KEY]);
}
```

---

## `src/api/client.ts` (Axios + refresh autom√°tico com fila)

```ts
import axios, { AxiosError, AxiosInstance } from "axios";
import {
  getAccessToken,
  getRefreshToken,
  setTokens,
  clearTokens,
} from "../auth/tokens";

// Emulador Android usa 10.0.2.2; iOS simulador pode usar localhost
const BASE_URL = "http://10.0.2.2:4000";

export const API: AxiosInstance = axios.create({
  baseURL: BASE_URL,
  timeout: 10000,
});

// Header inicial
(async () => {
  const access = await getAccessToken();
  if (access) API.defaults.headers.common.Authorization = `Bearer ${access}`;
})();

let refreshing = false;
let waiters: { resolve: (t: string) => void; reject: (e: unknown) => void }[] =
  [];

function enqueueWaiter() {
  return new Promise<string>((resolve, reject) =>
    waiters.push({ resolve, reject })
  );
}
function resolveWaiters(token: string) {
  waiters.forEach((w) => w.resolve(token));
  waiters = [];
}
function rejectWaiters(err: unknown) {
  waiters.forEach((w) => w.reject(err));
  waiters = [];
}

API.interceptors.response.use(
  (res) => res,
  async (error: AxiosError) => {
    const original: any = error.config || {};

    if (error.response?.status === 401 && !original._retry) {
      original._retry = true;

      if (refreshing) {
        const token = await enqueueWaiter();
        original.headers = {
          ...original.headers,
          Authorization: `Bearer ${token}`,
        };
        return API(original);
      }

      try {
        refreshing = true;
        const refreshToken = await getRefreshToken();
        if (!refreshToken) throw new Error("No refresh token");

        const { data } = await API.post("/auth/refresh", { refreshToken });
        const { accessToken, refreshToken: newRefresh } = data;

        await setTokens(accessToken, newRefresh);
        API.defaults.headers.common.Authorization = `Bearer ${accessToken}`;
        resolveWaiters(accessToken);

        original.headers = {
          ...original.headers,
          Authorization: `Bearer ${accessToken}`,
        };
        return API(original);
      } catch (e) {
        rejectWaiters(e);
        await clearTokens();
        // aqui voc√™ pode emitir um evento para a navega√ß√£o ir para Login
        return Promise.reject(e);
      } finally {
        refreshing = false;
      }
    }

    return Promise.reject(error);
  }
);
```

---

## `src/context/AuthContext.tsx` (estado global e bootstrap)

```tsx
import React, {
  createContext,
  useContext,
  useEffect,
  useMemo,
  useState,
} from "react";
import { API } from "../api/client";
import {
  clearTokens,
  getAccessToken,
  getRefreshToken,
  setTokens,
} from "../auth/tokens";

type Role = "user" | "admin";
export interface User {
  id: string;
  email: string;
  roles: Role[];
}

type Status = "loading" | "signedOut" | "signedIn";

interface AuthContextValue {
  status: Status;
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  hasRole: (role: Role) => boolean;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [status, setStatus] = useState<Status>("loading");
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    (async () => {
      // bootstrap: tenta /private/me se houver access token
      const access = await getAccessToken();
      if (!access) {
        setStatus("signedOut");
        return;
      }
      try {
        const { data } = await API.get("/private/me");
        setUser(data);
        setStatus("signedIn");
      } catch {
        // tenta refresh se houver
        try {
          const rt = await getRefreshToken();
          if (!rt) throw new Error("no rt");
          const { data } = await API.post("/auth/refresh", {
            refreshToken: rt,
          });
          await setTokens(data.accessToken, data.refreshToken);
          const me = await API.get("/private/me");
          setUser(me.data);
          setStatus("signedIn");
        } catch {
          await clearTokens();
          setStatus("signedOut");
        }
      }
    })();
  }, []);

  const login = async (email: string, password: string) => {
    const { data } = await API.post("/auth/login", { email, password });
    await setTokens(data.accessToken, data.refreshToken);
    API.defaults.headers.common.Authorization = `Bearer ${data.accessToken}`;
    setUser(data.user);
    setStatus("signedIn");
  };

  const logout = async () => {
    try {
      const rt = await getRefreshToken();
      if (rt) await API.post("/auth/logout", { refreshToken: rt });
    } catch {}
    await clearTokens();
    setUser(null);
    setStatus("signedOut");
  };

  const hasRole = (role: Role) => !!user?.roles?.includes(role);

  const value = useMemo(
    () => ({ status, user, login, logout, hasRole }),
    [status, user]
  );
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error("useAuth must be used within AuthProvider");
  return ctx;
}
```

---

## `src/navigation/AppNavigator.tsx` (stacks p√∫blicas/privadas)

```tsx
import React from "react";
import { NavigationContainer } from "@react-navigation/native";
import { createNativeStackNavigator } from "@react-navigation/native-stack";
import { useAuth } from "../context/AuthContext";
import SplashScreen from "../screens/SplashScreen";
import LoginScreen from "../screens/LoginScreen";
import HomeScreen from "../screens/HomeScreen";
import AdminScreen from "../screens/AdminScreen";

export type RootStackParamList = {
  Splash: undefined;
  Login: undefined;
  Home: undefined;
  Admin: undefined;
};

const Stack = createNativeStackNavigator<RootStackParamList>();

const AppNavigator = () => {
  const { status } = useAuth();

  if (status === "loading") {
    return (
      <NavigationContainer>
        <Stack.Navigator>
          <Stack.Screen
            name="Splash"
            component={SplashScreen}
            options={{ headerShown: false }}
          />
        </Stack.Navigator>
      </NavigationContainer>
    );
  }

  return (
    <NavigationContainer>
      {status === "signedOut" ? (
        <Stack.Navigator>
          <Stack.Screen
            name="Login"
            component={LoginScreen}
            options={{ title: "Login" }}
          />
        </Stack.Navigator>
      ) : (
        <Stack.Navigator>
          <Stack.Screen
            name="Home"
            component={HomeScreen}
            options={{ title: "Home" }}
          />
          <Stack.Screen
            name="Admin"
            component={AdminScreen}
            options={{ title: "Admin" }}
          />
        </Stack.Navigator>
      )}
    </NavigationContainer>
  );
};

export default AppNavigator;
```

---

## `src/components/AdminOnly.tsx` (guard de papel)

```tsx
import React from "react";
import { View, Text } from "react-native";
import { useAuth } from "../context/AuthContext";

const AdminOnly: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { hasRole } = useAuth();
  if (!hasRole("admin"))
    return (
      <View style={{ padding: 16 }}>
        <Text>Acesso negado (admin apenas).</Text>
      </View>
    );
  return <>{children}</>;
};

export default AdminOnly;
```

---

## `src/screens/SplashScreen.tsx`

```tsx
import React from "react";
import { View, ActivityIndicator } from "react-native";

export default function SplashScreen() {
  return (
    <View style={{ flex: 1, alignItems: "center", justifyContent: "center" }}>
      <ActivityIndicator />
    </View>
  );
}
```

## `src/screens/LoginScreen.tsx`

```tsx
import React, { useState } from "react";
import { View, Text, TextInput, Button } from "react-native";
import { useAuth } from "../context/AuthContext";

export default function LoginScreen() {
  const { login } = useAuth();
  const [email, setEmail] = useState("admin@example.com");
  const [password, setPassword] = useState("admin123");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const onSubmit = async () => {
    setLoading(true);
    setError("");
    try {
      await login(email, password);
    } catch (e: any) {
      setError(e?.response?.data?.error || "Login failed");
    }
    setLoading(false);
  };

  return (
    <View style={{ padding: 24, gap: 12 }}>
      <Text style={{ fontSize: 22, fontWeight: "bold" }}>Entrar</Text>
      {!!error && <Text style={{ color: "red" }}>{error}</Text>}
      <TextInput
        placeholder="Email"
        autoCapitalize="none"
        keyboardType="email-address"
        value={email}
        onChangeText={setEmail}
        style={{ borderWidth: 1, padding: 10 }}
      />
      <TextInput
        placeholder="Senha"
        secureTextEntry
        value={password}
        onChangeText={setPassword}
        style={{ borderWidth: 1, padding: 10 }}
      />
      <Button
        title={loading ? "..." : "Login"}
        onPress={onSubmit}
        disabled={loading}
      />
    </View>
  );
}
```

## `src/screens/HomeScreen.tsx`

```tsx
import React from "react";
import { View, Text, Button, Alert } from "react-native";
import { useAuth } from "../context/AuthContext";
import { API } from "../api/client";

export default function HomeScreen({ navigation }: any) {
  const { user, logout } = useAuth();

  const callMe = async () => {
    try {
      const { data } = await API.get("/private/me");
      Alert.alert("ME", JSON.stringify(data));
    } catch (e: any) {
      Alert.alert("Erro", e?.response?.data?.error || "Falha");
    }
  };

  const callAdmin = async () => {
    try {
      const { data } = await API.get("/private/admin/metrics");
      Alert.alert("ADMIN", JSON.stringify(data));
    } catch (e: any) {
      Alert.alert("Sem permiss√£o", JSON.stringify(e?.response?.data || {}));
    }
  };

  return (
    <View style={{ padding: 24, gap: 12 }}>
      <Text style={{ fontSize: 18, fontWeight: "bold" }}>
        Bem-vindo, {user?.email}
      </Text>
      <Button title="/private/me" onPress={callMe} />
      <Button title="/private/admin/metrics" onPress={callAdmin} />
      <Button
        title="Ir para tela Admin"
        onPress={() => navigation.navigate("Admin")}
      />
      <Button title="Logout" onPress={logout} />
    </View>
  );
}
```

## `src/screens/AdminScreen.tsx`

```tsx
import React from "react";
import { View, Text } from "react-native";
import AdminOnly from "../components/AdminOnly";

export default function AdminScreen() {
  return (
    <AdminOnly>
      <View style={{ padding: 24 }}>
        <Text style={{ fontWeight: "bold", fontSize: 18 }}>
          √Årea do Administrador
        </Text>
        <Text>Somente usu√°rios com papel `admin` podem ver esta tela.</Text>
      </View>
    </AdminOnly>
  );
}
```

---

## `App.tsx`

```tsx
import React from "react";
import { StatusBar } from "expo-status-bar";
import { AuthProvider } from "./src/context/AuthContext";
import AppNavigator from "./src/navigation/AppNavigator";

export default function App() {
  return (
    <AuthProvider>
      <StatusBar style="auto" />
      <AppNavigator />
    </AuthProvider>
  );
}
```

---

## ‚úÖ Dicas de execu√ß√£o

- Inicie o backend em `http://localhost:4000`.
- Dispositivo f√≠sico: use o IP da sua m√°quina (ex.: `http://192.168.0.10:4000`).

---
